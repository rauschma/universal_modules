/**
 * Normalized name:
 * - "../foo" = file foo in the directory above the current directory
 * - "" = current directory
 * - "foo" = file foo in current directory
 *
 * Module name:
 * - "./foo" look for a sibling of the current file
 * - "../foo" look for "foo" in the directory above the current file
 */

var umodules_browser = function() {
    
    //---------- Private
    
    /**
     * Code by Nicholas C. Zakas, with minor modifications
     * @see http://www.nczonline.net/blog/2009/07/28/the-best-way-to-load-external-javascript/
     */
    function loadScript(url, callback) {
        var script = document.createElement("script")
        script.type = "text/javascript";

        if (script.readyState) {  // IE
            script.onreadystatechange = function () {
                if (script.readyState === "loaded" ||
                        script.readyState === "complete") {
                    script.onreadystatechange = null;
                    callback();
                }
            };
        } else {  // Others
            script.onload = function(){
                callback();
            };
        }

        script.src = url;
        document.getElementsByTagName("head")[0].appendChild(script);
    }
    function removePrefixMaybe(prefix, str) {
        if (str.indexOf(prefix) === 0) {
            return str.slice(prefix.length);
        } else {
            return str;
        }
    }

    function startsWith(str, prefix) {
        return str.indexOf(prefix) === 0;
    };
    function endsWith(str, suffix) {
        var index = str.lastIndexOf(suffix);
        return index >= 0 && index === str.length - suffix.length;
    };

    var moduleCache = {};
    var globalNames = {};
    
    /** normalizedName, importNames, body */
    var currentModuleDesc;

    function invokeModule(desc, callback) {
        var importObjects = [];
        var importCount = 0;
        if (!desc.importNames || desc.importNames.length === 0) {
            maybeFinish();
        } else {
            for(var index=0; index<desc.importNames.length; index++) {
                // IIFE ensures new variables for each loop iteration
                (function() {
                    var importName = desc.importNames[index];
                    var normalizedName = exports.normalizeImportName(desc.normalizedName, importName);
                    
                    if (moduleCache[normalizedName]) {
                        addImport(index, moduleCache[normalizedName]);
                    } else {
                        var indexCopy = index;
                        loadScript(normalizedName+".js", function () {
                            var newDesc = currentModuleDesc;
                            currentModuleDesc = null;
                            newDesc.normalizedName = normalizedName;
                            invokeModule(newDesc, function (data) {
                                addImport(indexCopy, data);
                            });
                        });
                    }
                }());
            }
        }
        function addImport(index, data) {
            importObjects[index] = data;
            importCount++;
            maybeFinish();
        }
        function maybeFinish() {
            if (importCount === desc.importNames.length) {
                var result = desc.body.apply(null, importObjects);
                if (callback) {
                    callback(result);
                }
            }
        }
    }

    //---------- Public

    var exports = {
        /** Maps a global module name to either a path or an object */
        globalNames: {},
        
        /** Store module so that it can be processed by the script loading callback */
        module: function (importNames, body) {
            currentModuleDesc = {
                importNames: importNames,
                body: body
            };
        },
        /** Execute module right away */
        main: function (importNames, body) {
            invokeModule({
                importNames: importNames,
                body: body,
                normalizedName: "__MAIN__"
            });
        },
    
        goToParentDir: function (name) {
            if (name.length === 0) {
                return "..";
            }
            if (/^[.][.]([/][.][.])*$/.test(name)) {
                return "../"+name;
            }
            
            var slashIndex = name.lastIndexOf("/");
            if (slashIndex < 0) {
                return ""; // the current directory
            } else {
                return name.slice(0, slashIndex);
            }
        },
        
        descend: function (base, path) {
            if (base.length === 0) {
                return path;
            } else {
                return base + "/" + path;
            }
        },
    
        isLegalNormalizedName: function (name) {
            // Can be absolute
            // Can be relative: "../foo" or "bar", but not "./bar"
            // Must be a JS file after appending ".js"
            return !endsWith(name, "/") && !startsWith(name, "./");
        },
        
        normalizeImportName: function (baseName, importName) {
            if (!exports.isLegalNormalizedName(baseName)) {
                throw new Error("Illegal normalized name: "+baseName);
            }
            if (startsWith(importName, "/")) {
                // absolute name
                return importName;
            }
            if (startsWith(importName, "./") || startsWith(importName, "../")) {
                // relative name: go down in current directory (possibly after going up)
                baseName = exports.goToParentDir(baseName); // go to current directory
            
                if (startsWith(importName, "./")) {
                    importName = removePrefixMaybe("./", importName);
                } else {
                    while (startsWith(importName, "../")) {
                        // going up
                        importName = removePrefixMaybe("../", importName);
                        baseName = exports.goToParentDir(baseName);
                    }
                }
                // Now go down
                return exports.descend(baseName, importName);
            } else {
                // global name
                var resolved = globalNames[importName];
                switch(typeof resolved) {
                    case "object": // also result for null, but can't happen here
                        if (!moduleCache[importName]) {
                            moduleCache[importName] = resolved;
                        }
                        return importName;
                    case "string":
                        return resolved;
                    case "undefined":
                        throw new Error("Unknown global name: "+importName);
                    default:
                        throw new Error("Illegal mapping value: "+resolved);
                }
            }
        }
    };
    return exports;
}();
