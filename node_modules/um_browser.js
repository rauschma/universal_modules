if (window && !window.global) {
    // It would be nice to achieve this without <tt>window</tt>, but there is no easy way to do so.
    window.global = window;
}

/**
 * Normalized name (extension ".js" is cut off)
 * - "../foo" = file foo in the directory above the current directory
 * - "" = current directory
 * - "foo" = file foo in current directory
 * - "bar/foo" = descend into bar to get to file foo
 *
 * Module name:
 * - "./foo" look for a sibling of the current file
 * - "../foo" look for "foo" in the directory above the current file
 */
var umodules_browser = function() {
    
    //---------- Private
    
    /**
     * Code by Nicholas C. Zakas, with minor modifications
     * @see http://www.nczonline.net/blog/2009/07/28/the-best-way-to-load-external-javascript/
     */
    function loadScript(url, callback) {
        var script = document.createElement("script")
        script.type = "text/javascript";

        if (script.readyState) {  // IE
            script.onreadystatechange = function () {
                if (script.readyState === "loaded" ||
                        script.readyState === "complete") {
                    script.onreadystatechange = null;
                    callback();
                }
            };
        } else {  // Others
            script.onload = function(){
                callback();
            };
        }

        script.src = url;
        document.getElementsByTagName("head")[0].appendChild(script);
    }
    function removePrefixMaybe(prefix, str) {
        if (str.indexOf(prefix) === 0) {
            return str.slice(prefix.length);
        } else {
            return str;
        }
    }

    function startsWith(str, prefix) {
        return str.indexOf(prefix) === 0;
    }
    
    function endsWith(str, suffix) {
        var index = str.lastIndexOf(suffix);
        return index >= 0 && index === str.length - suffix.length;
    }

    var moduleCache = {};
    var currentlyLoading = {};
    var recursionDepth = 0;
    
    /**
     * Filled in by a module() call, to pass it on to the onload handler.
     *
     * Properties of this object:
     * - normalizedName: must be filled in by loader. The loaded script does not know its
     *   position relative to the
     * - importNames, body: filled in by the loaded script (parameters of module())
     */
    var currentModuleDesc;

    /**
     * Asynchronously invoke the body of the given module,
     * after all of its imports have loaded.
     */
    function loadModule(moduleDesc, callback) {
        if (!moduleDesc.normalizedName) {
            throw new Error("Missing normalizedName");
        }
        if (moduleCache[moduleDesc.normalizedName]) {
            return moduleCache[moduleDesc.normalizedName];
        }
        if (currentlyLoading[moduleDesc.normalizedName]) {
            throw new Error("Import cycle: "+moduleDesc.normalizedName);
        }
        currentlyLoading[moduleDesc.normalizedName] = true;
        recursionDepth++;
        
        if (!moduleDesc.importNames || moduleDesc.importNames.length === 0) {
            applyModuleBody();
        } else {
            moduleDesc.importNames.forEach(function(importName, index) {
                var normalizedName = exports._normalizeImportName(moduleDesc.normalizedName, importName);
                loadScript(normalizedName+".js", function () {
                    var newDesc = currentModuleDesc;
                    currentModuleDesc = null;
                    newDesc.normalizedName = normalizedName;
                    loadModule(newDesc, function (result) {
                        addImport(index, result);
                    });
                });
            });
        }
        var importObjects = [];
        var importCount = 0;
        function addImport(index, data) {
            importObjects[index] = data;
            importCount++;
            if (importCount === moduleDesc.importNames.length) {
                applyModuleBody();
            }
        }
        function applyModuleBody() {
            var result = moduleDesc.body.apply(null, importObjects);
            delete currentlyLoading[moduleDesc.normalizedName];
            recursionDepth--;
            moduleCache[moduleDesc.normalizedName] = result;
            if (callback) {
                callback(result);
            }
        }
    }

    if (global.define) {
        throw new Error("The global variable ‘define’ is already in use");
    }

    global.define = function (importNames, body) {
        if (arguments.length === 1 && typeof importNames === "function") {
            body = importNames;
            importNames = [];
        }
        
        if (recursionDepth === 0) {
            // Execute module right away
            loadModule({
                importNames: importNames,
                body: body,
                normalizedName: "__MAIN__"
            });
        } else {
            // Store module so that it can be processed by the script loading callback
            currentModuleDesc = {
                importNames: importNames,
                body: body
            };
        }
    }

    //----------

    var exports = {
        /**
         * Either:
         * - Object: maps a global module name to either a path or an object (the module)
         * - Function: takes a global name and returns a path or an object
         */
        globalNames: {},
    
        //---- exported - to be testable
        
        _goToParentDir: function (name) {
            if (name.length === 0) {
                return "..";
            }
            if (/^[.][.]([/][.][.])*$/.test(name)) {
                // We are currently *only* going up (as opposed to going up and down)
                return "../"+name;
            }
            
            // We are going down (possibly after going up)
            // => we can go up by removing the last path name segment
            var slashIndex = name.lastIndexOf("/");
            if (slashIndex < 0) {
                return ""; // the current directory
            } else {
                return name.slice(0, slashIndex);
            }
        },
        
        _descend: function (base, path) {
            if (base.length === 0) {
                return path;
            } else {
                return base + "/" + path;
            }
        },
    
        _isLegalNormalizedName: function (name) {
            // Can be absolute
            // Can be relative: "../foo" or "bar", but not "./bar"
            // Must be a JS file after appending ".js"
            return !endsWith(name, "/") && !startsWith(name, "./");
        },
        
        _normalizeImportName: function (baseName, importName) {
            if (!exports._isLegalNormalizedName(baseName)) {
                throw new Error("Illegal normalized name: "+baseName);
            }
            if (startsWith(importName, "/")) {
                // absolute name
                return importName;
            }
            if (startsWith(importName, "./") || startsWith(importName, "../")) {
                // relative name: go down in current directory (possibly after going up)
                baseName = exports._goToParentDir(baseName); // go to current directory
            
                if (startsWith(importName, "./")) {
                    importName = removePrefixMaybe("./", importName);
                } else {
                    while (startsWith(importName, "../")) {
                        // going up
                        importName = removePrefixMaybe("../", importName);
                        baseName = exports._goToParentDir(baseName);
                    }
                }
                // Now go down
                return exports._descend(baseName, importName);
            } else {
                // global name
                var resolvedName;
                if (typeof exports.globalNames === "function") {
                    resolvedName = exports.globalNames(importName);
                } else {
                    resolvedName = exports.globalNames[importName];
                }
                switch(typeof resolvedName) {
                    case "object": // also result for null, but can't happen here
                        if (!moduleCache[importName]) {
                            moduleCache[importName] = resolvedName;
                        }
                        return importName;
                    case "string":
                        return resolvedName;
                    case "undefined":
                        throw new Error("Unknown global name: "+importName);
                    default:
                        throw new Error("Illegal mapping value: "+resolvedName);
                }
            }
        }
    };
    return exports;
}();
